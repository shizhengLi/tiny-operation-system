### 总体概述
构建一个小型操作系统（类似于Linux，但简化版）是一个复杂但可分解的项目。我们将采用“小步快跑”的敏捷开发方法：每个阶段聚焦于一个小功能模块，先实现核心逻辑，然后编写单元测试（针对单个函数或模块）和集成测试（验证模块与其他部分的交互）。只有所有测试通过后，才进入下一阶段。这有助于及早发现问题，并保持项目可管理。

**假设和前提：**
- 目标平台：x86-64架构（常见于PC），使用QEMU模拟器进行测试（无需物理硬件）。
- 编程语言：主要使用C语言（内核部分），汇编（引导和低级部分），可能少量Rust或其他如果需要现代特性。
- 工具链：GCC交叉编译器、NASM汇编器、Make构建系统、GDB调试器。
- 测试框架：自定义简单测试框架（例如，使用assert宏），或集成像Unity这样的C测试库。
- 版本控制：使用Git跟踪每个阶段的提交。
- 规模：目标是一个最小可引导的内核，支持基本进程、多任务、简单文件系统和shell。类似于一个微内核或简化版Unix-like OS。
- 时间估计：每个阶段1-2周，视经验而定。总计3-6个月。

**开发原则：**
- 每个阶段结束时，提交代码到Git，并运行所有测试。
- 如果测试失败，修复bug直到100%通过。
- 文档：每个阶段维护README，记录API和设计决策。
- 风险管理：如果某个阶段卡住，回滚到上一个稳定版本。

### 详细计划
以下是分阶段计划，按顺序执行。每个阶段包括：
- **目标**：要实现的功能。
- **子任务**：具体步骤。
- **单元测试**：针对单个组件的测试。
- **集成测试**：模块间交互测试。
- **通过标准**：所有测试覆盖率>80%，无崩溃/内存泄漏。
- **输出**：阶段结束时的可运行产物。

| 阶段 | 目标 | 子任务 | 单元测试 | 集成测试 | 通过标准及输出 |
|------|------|--------|----------|----------|---------------|
| 1: 设置开发环境 | 建立基础工具链，确保能编译和运行简单程序。 | 1. 安装GCC、Binutils交叉编译器（针对x86-64）。<br>2. 安装QEMU、NASM。<br>3. 创建Makefile模板。<br>4. 编写一个“Hello World”内核stub（汇编+C）。<br>5. 配置Git仓库。 | 测试编译器：编译简单C文件，检查无警告。<br>测试QEMU：运行一个空镜像，确保启动。 | 无（首次阶段）。 | 所有工具安装成功，能在QEMU中运行空内核（黑屏无崩溃）。输出：可引导的空镜像文件。 |
| 2: 引导程序（Bootloader） | 实现BIOS/UEFI引导，加载内核到内存。 | 1. 编写汇编引导代码（MBR或UEFI入口）。<br>2. 设置栈和段寄存器。<br>3. 跳转到C内核main函数。<br>4. 处理多引导规范（Multiboot）。 | 测试引导函数：模拟加载内存，检查寄存器值。<br>测试栈初始化：assert栈指针正确。 | 在QEMU中引导，检查是否进入内核main（打印消息）。 | 引导成功，无段错误。输出：可引导的内核镜像，能打印“Kernel Loaded”。 |
| 3: 内核初始化 | 初始化CPU模式、内存映射和基本I/O。 | 1. 进入保护模式/长模式。<br>2. 设置GDT/IDT（全局/中断描述符表）。<br>3. 实现基本printf（串口或VGA输出）。<br>4. 处理基本中断（时钟、键盘）。 | 测试GDT加载：模拟加载，检查表条目。<br>测试printf：输入字符串，检查输出缓冲区。 | 集成引导：从引导跳转到初始化，打印初始化消息。<br>中断测试：模拟时钟中断，确保处理函数调用。 | 系统启动无崩溃，能响应键盘输入。输出：可打印消息的内核。 |
| 4: 内存管理 | 实现物理/虚拟内存分配器。 | 1. 解析Multiboot内存映射。<br>2. 实现简单位图或buddy分配器（物理页）。<br>3. 设置分页（虚拟内存）。<br>4. 实现kmalloc/kfree。 | 测试分配器：分配/释放块，检查无重叠。<br>测试分页：映射页，检查地址转换。 | 集成初始化：使用分配器初始化数据结构。<br>加载测试：分配大块内存，确保不崩溃。 | 内存泄漏检测（Valgrind-like工具），分配成功率100%。输出：支持动态内存的内核。 |
| 5: 进程管理 | 支持基本多任务和调度。 | 1. 定义进程结构体（PCB）。<br>2. 实现上下文切换（保存/恢复寄存器）。<br>3. 简单调度器（轮询或优先级）。<br>4. 创建init进程。 | 测试PCB：创建进程，检查字段值。<br>测试切换：模拟两个进程，检查寄存器恢复。 | 集成内存：进程使用kmalloc分配栈。<br>运行测试：启动两个进程，交替打印消息。 | 多进程运行无死锁，调度公平。输出：能运行多个进程的内核。 |
| 6: 系统调用 | 实现用户/内核模式切换和基本syscall。 | 1. 设置syscall中断（int 0x80或syscall指令）。<br>2. 实现exit、fork、exec等基本调用。<br>3. 用户模式环切换。 | 测试syscall处理：模拟调用，检查参数传递。<br>测试fork：复制进程，检查独立性。 | 集成进程：从用户进程调用syscall，返回内核。<br>端到端：用户程序调用exit，进程终止。 | syscall无越界，所有进程正常退出。输出：支持用户程序的内核。 |
| 7: 文件系统 | 实现简单文件系统（如ramfs或ext2简化版）。 | 1. 定义inode和superblock。<br>2. 实现读/写文件操作。<br>3. 挂载根文件系统。<br>4. 支持目录遍历。 | 测试inode：创建文件，检查元数据。<br>测试读写：写入数据，读取验证。 | 集成syscall：通过open/read/write syscall访问文件。<br>进程测试：进程打开文件，无冲突。 | 文件操作一致性，无数据丢失。输出：有文件系统的内核，能列出根目录。 |
| 8: 设备驱动 | 添加基本I/O设备支持。 | 1. 键盘/鼠标驱动。<br>2. 磁盘驱动（模拟ATA）。<br>3. 定时器驱动。 | 测试键盘：模拟按键，检查缓冲区。<br>测试磁盘：读写扇区，验证数据。 | 集成文件系统：使用磁盘加载文件。<br>进程测试：进程读取输入，无阻塞。 | 输入输出正确，定时器中断准时。输出：支持外设的内核。 |
| 9: Shell和用户空间 | 实现简单命令行shell。 | 1. 编写用户态shell程序（ls、cd、echo）。<br>2. 编译并加载到内核。<br>3. 处理命令解析和执行。 | 测试命令解析：输入字符串，检查参数。<br>测试ls：模拟目录，检查输出。 | 集成全部：从引导到shell，运行命令。<br>多任务：shell中fork子进程。 | shell稳定运行，支持基本命令。输出：完整小型OS，能交互。 |
| 10: 优化和测试 | 整体优化、安全检查和扩展。 | 1. 添加错误处理和panic。<br>2. 性能调优（调度、内存）。<br>3. 安全审计（缓冲区溢出）。<br>4. 可选扩展（如网络栈）。 | 重新运行所有单元测试。<br>压力测试：高负载下检查。 | 全系统集成：模拟多用户场景。<br>端到端：从引导到关机。 | 覆盖率>90%，无已知bug。输出：稳定版本OS。 |

### 后续建议
- **资源**：参考书籍如《Operating Systems: Three Easy Pieces》、《Linux Kernel Development》。在线教程：OSDev wiki、Writing a Simple Operating System from Scratch。
- **调试**：使用QEMU+GDB单步调试。
- **扩展**：如果成功，可添加GUI、网络等，但保持小步。
- **挑战**：低级编程易出错，建议从阶段1开始实践。如果卡在某阶段，寻求社区帮助（如Reddit r/osdev）。

这个计划是灵活的，根据实际进度调整，但严格遵守测试通过原则。开始吧，从阶段1设置环境！