# 阶段4: 系统服务技术文档

## 概述

阶段4成功实现了完整的系统服务层，为微型操作系统提供了系统调用接口、进程管理、内存管理、设备驱动和基本文件系统功能。本阶段标志着操作系统从基础的内核初始化阶段发展到具备实际服务能力的阶段。

## 核心功能实现

### 1. 系统调用接口

**文件**: `src/syscall.asm`, `src/syscall_handlers.c`

系统调用接口是用户程序与操作系统内核交互的主要机制：

- **系统调用入口**: 使用 INT 0x80 中断作为系统调用入口点
- **调用规范**: 通过 eax 寄存器传递系统调用号，ebx、ecx、edx、esi、edi 传递参数
- **支持的系统调用**:
  - SYSCALL_EXIT (0): 进程退出
  - SYSCALL_READ (1): 文件读取
  - SYSCALL_WRITE (2): 文件写入
  - SYSCALL_OPEN (3): 文件打开
  - SYSCALL_CLOSE (4): 文件关闭
  - SYSCALL_SEEK (5): 文件定位
  - SYSCALL_MMAP (6): 内存映射
  - SYSCALL_MUNMAP (7): 解除内存映射
  - SYSCALL_FORK (8): 进程创建
  - SYSCALL_EXEC (9): 程序执行
  - SYSCALL_WAIT (10): 进程等待
  - SYSCALL_KILL (11): 进程终止
  - SYSCALL_GETPID (12): 获取进程ID
  - SYSCALL_SLEEP (13): 进程休眠
  - SYSCALL_YIELD (14): 进程让出CPU

### 2. 进程管理

**文件**: `src/kernel_syscalls.c`

实现了完整的进程管理子系统：

**进程控制块 (PCB)**:
```c
struct process {
    uint32_t pid;
    uint32_t parent_pid;
    enum process_state state;
    uint32_t esp;
    uint32_t eip;
    uint32_t cr3;
    uint32_t kernel_stack;
    uint32_t user_stack;
    uint32_t exit_code;
    char name[32];
};
```

**进程状态**:
- PROCESS_UNUSED: 未使用
- PROCESS_READY: 就绪
- PROCESS_RUNNING: 运行
- PROCESS_BLOCKED: 阻塞
- PROCESS_ZOMBIE: 僵尸

**进程管理功能**:
- 支持16个并发进程
- 实现了简单的轮转调度算法
- 进程创建和终止机制
- 父子进程关系管理

### 3. 内存管理

**文件**: `src/kernel_syscalls.c`

实现了动态内存分配器：

**内存块结构**:
```c
struct memory_block {
    uint32_t size;
    uint32_t free;
    struct memory_block* next;
};
```

**内存管理功能**:
- 64KB 内存池
- malloc/free 动态内存分配
- 内存块分割和合并
- 内存对齐处理
- 内存碎片管理

### 4. 设备驱动

**文件**: `src/kernel_syscalls.c`, `src/interrupt_handlers.c`

实现了多种设备驱动程序：

**键盘驱动**:
- 键盘中断处理 (IRQ1)
- 扫描码到ASCII转换
- 字符输入缓冲

**定时器驱动**:
- 可编程间隔定时器 (PIT) 初始化
- 100Hz 定时器中断
- 系统时钟管理
- 进程调度时钟

**显示驱动**:
- VGA文本模式输出
- 颜色管理
- 光标控制
- 屏幕滚动

### 5. 文件系统

**文件**: `src/kernel_syscalls.c`

实现了基本文件系统抽象：

**文件描述符结构**:
```c
struct file_descriptor {
    uint32_t inode;
    uint32_t offset;
    uint32_t flags;
    void* device_data;
};
```

**文件系统功能**:
- 256个文件描述符
- 标准输入/输出/错误流
- 文件打开/关闭/读写操作
- 文件定位功能

## 技术特点

### 1. 模块化设计
- 清晰的功能模块划分
- 良好的接口定义
- 可扩展的架构设计

### 2. 混合编程模式
- C语言实现高层逻辑
- 汇编语言处理底层操作
- 内联汇编优化关键路径

### 3. 中断处理机制
- 完整的中断描述符表 (IDT)
- 可编程中断控制器 (PIC) 配置
- 中断上下文保存和恢复
- 中断处理程序分发

### 4. 系统调用机制
- 统一的系统调用接口
- 标准的参数传递约定
- 完整的系统调用处理流程
- 错误处理机制

## 性能优化

### 1. 内存管理优化
- 内存块合并减少碎片
- 4字节对齐提高访问效率
- 首次适应分配算法

### 2. 进程调度优化
- 简单的轮转调度
- 定时器中断触发调度
- 进程状态快速切换

### 3. 中断处理优化
- 快速中断处理路径
- 最小化中断屏蔽时间
- 延迟处理非关键操作

## 测试和验证

### 1. 系统调用测试
实现了完整的系统调用测试程序：
- write 系统调用测试
- getpid 系统调用测试
- sleep 系统调用测试
- 异常处理测试

### 2. 启动测试
成功在 QEMU 模拟器中启动：
- 引导程序正常工作
- 内核正确加载
- 保护模式成功进入
- 系统服务初始化完成

### 3. 功能验证
验证了以下功能：
- VGA 文本输出
- 键盘输入处理
- 定时器中断
- 内存分配释放
- 系统调用执行

## 文件结构

```
src/
├── kernel_syscalls.c      # 主内核文件（系统调用版本）
├── syscall.asm           # 系统调用汇编处理程序
├── syscall_handlers.c    # 系统调用C处理程序
├── interrupt_handlers.c  # 中断处理程序
└── isr.asm              # 中断服务例程
```

## 构建系统

### 1. Makefile 配置
支持多种构建目标：
- `all`: 构建系统调用内核（默认）
- `kernel-sys`: 构建系统调用内核
- `floppy`: 创建启动盘镜像
- `run-sys`: 在 QEMU 中运行系统调用内核

### 2. 编译选项
- 32位保护模式编译
- 无标准库支持
- 严格的编译警告
- 优化级别 O2

## 已知限制

### 1. 功能限制
- 内存池大小固定（64KB）
- 进程数量有限（16个）
- 无虚拟内存支持
- 无真正的文件系统

### 2. 性能限制
- 简单的调度算法
- 无内存分页
- 无缓存机制
- 同步中断处理

## 未来改进方向

### 1. 功能扩展
- 实现真正的文件系统
- 添加网络支持
- 实现虚拟内存
- 支持更多系统调用

### 2. 性能优化
- 实现更智能的调度算法
- 添加内存分页
- 实现缓存机制
- 优化中断处理

### 3. 安全性增强
- 实现用户空间/内核空间分离
- 添加权限检查
- 实现内存保护
- 增加错误处理

## 总结

阶段4成功实现了完整的系统服务层，为微型操作系统提供了：
- 完整的系统调用接口
- 基本的进程管理功能
- 动态内存管理
- 多种设备驱动
- 基本文件系统抽象

这些功能构成了一个基本的操作系统内核，为进一步的功能扩展奠定了坚实的基础。系统具备了处理用户请求、管理资源、调度进程的基本能力，标志着操作系统开发从基础设施阶段进入到服务提供阶段。

通过 QEMU 模拟器的测试验证，系统服务功能运行正常，为后续阶段的开发提供了可靠的验证平台。